				 Microservices
.....................................................................................

Application(software system) Develpment patterns:
.................................................

Network based Applications - Distributed Application

Application has layers:

1.User interface layer
2.Application biz layer
3.Data Layer /Repository layer

Histrory of Architecture of Distributed Application

Distributed means, application is broken into multiple parts and each part put into multiple hosts/machines, connect those via network.

1.Mainframework based distributed
   1.Application biz layer
   2.Data Layer /Repository layer
 Where as User interface layer is kept in dump terminals connected to mainframworks.

Drawbacks:
1.Too costly
2.scalability is too difficult.


Advantage:
1.High security
2.Centeralized management.

2.Client Server Architecture

2.1.Main framework based client -server , where as mainframe acts as server and digital computers act as clients.
 
2.2.Digital computer based client - server architechture
   Servers and clients are digital computers

Based on this we can classify the applications  layered /tiered concept


1.single tier/layer
   client,server,database every is kept in one single machine...
2.two tier/layer
  user interface is kept in client machine,
  data logic and biz logic is kept in server machine
 both machines are connected via networks

          "This arch based on LAN /WAN"

3.three tier /layer

 This arch based on "internet network" and web computing

   client - client machine
   server - biz logic is kept inside another machine
   database - is kept inside another machine

 Client is browser
 Server BIZ logic is kept as "web Applications"
 Database is accessed by "Server side technologies - J2EE,ASP/.net,PHP,....

4.N-tier / layer

 Client is browser
 Server BIZ logic is kept as "web Applications"
   -Again spilt into multi layered
 Database is accessed by "Server side technologies - J2EE,ASP/.net,PHP,....
 In 2000 , J2EE introduced n-tier client server  

  browser -------web application(servlets/jsp)----EJB----Messaging/Databases(JMS/JDBC/Middlewares)

 Spring based N-tier client server arch:

  browser -------web application(spring mvc)---Spring serivices----Spring data----Messaging/Databases(JMS/JDBC/Middlewares)
.....................................................................................
		    How to build N-tier distributed Applications
.....................................................................................

Steps/Process:

1.Domain Modeling

  Banking, Online Food Delivery App, Ecommerce Domain

2.Select technology

   if your app is based on web and internet.
  Steps:
   1. Database -  Oracle 
   2. MOM - RabbitMQ,IBM MQ,Microsoft MQ
   3. Development Technology
       Java/JEE  - Why you go with specific implmentation technologies?
       .Net
       Php

3.Development and release methodology
   Waterfall -  traditional dev , release


Any domain consist of various modules
 -Accounts
 -Loans
 -Customers
 -Card
etc.....
 
4.Testing
   Once the development is over, the app is going to be under testing

5.Production
   Once the app is tested fully, ready for production.

6.Maintance
   Once the app in the production, it goes on maintaince...

if any app is built based on the above methodology, which is called as "Monolithic"
.....................................................................................
 Challanges in the application development,testing,relase,Production,maintaince
....................................................................................


1.Every thing has to go step by step -  this increase cost , time waste,resource waste

Companies like Amazon,Netflix who wanted fast development,test,release,maintaince : Dynamic  methodology to build applications -  No downtime,
One module takes more time ,another module takes less time, because of one module , other module should not wait.

2.Technology bottleneck - Mono technology
 
 The whole application is built using single technology - Java - vendor lock
 The whole application targets single database - Oracle /Mysql/Microsoft SQL server..

3.Employing security layer is more complicated

4.Deployment / Production.

   The dev and prod env is completly different
   Bare deployment models
   VM based deployment...

...................................................................................
			  New way of building apps


1.Automatation is key concept 

   to anays,dev,test,release,prod,maintaince

Agile :(Requirement Analysis)

  Agile is an iterative approach to project management and software development that helps teams deliver value to their customers faster and with fewer headaches. Instead of betting everything on a "big bang" launch, an agile team delivers work in small, but consumable, increments

Breaks the application into smaller and smaller.
 - fast delivery with quality on time.


Requirments are highly dynamic, cant be freezed,since it is dynamic start development,test,release,deploy peridically.


We need automation, through which  automatically only we can achive fast delivery -
 in order to automate, a new technology was created "Dev Ops" - Dev + Operations togther.

Distributed source code repo - git

Pipe lines tools  - 
   Jenkins -(Continuous Integration)

Requirement---> Dev---push the code to source code repo---|CI Tool---Compile--Build/pack--Testing-Deployment(CD)

Every thing is here Continuous happens

Continuous Req Analysis
Continuous Dev 
Continuous release /build
Continuous test
Continuous release /build
Continuous deployment
Continuous tracing and monitoring

This process applied on every module in the applications
OrderManagement 
   Continuous Req Analysis,Dev,release,test,deployment,tracing,monitoring

CustomerManagement 
   Continuous Req Analysis,Dev,release,test,deployment,tracing,monitoring


if any app is built based on the above methodology, that application is called as 				  "MicroService"

...................................................................................
	     How to convert existing monolithic apps into microservices
.....................................................................................

Scalling means expanding either software or hardware resources..
if you scale software- horiziontal
if you scale hardware -vertical 

Why Scale Cube?

Increase performance
Make you app highly available..

X,Z => Scale instance of your app

X- based on Built in routing algorthims
Z- Custom routing algorthims

Assume that your app is already running in production,based on Monolithic model,
You have applied X scalling, that means your monolith app is running multiple instances.

Next step, you got assigment, you have to convert existing application(monolithic) into microservices?

How to begin?
 Apply scale cube pattern........ Y scalling 


Y-Axis scalling talks about how to spilt the existing monolith  application into micro services based on "functionals aspects" - Service


A Service is a "mini application" that implmements narrowly focused functionality.
Such as orderManagement,customer Management, and so on....

Some services are scalled based on "X-axis" and some services are "Z-scalling".


Your App
   -Y scalling
       -X or Z scalling....

The high level definition of microservices architecture(microservices) is an architectural style that "functionally decomposes an application into set of services(mini applcation)

In Monlolith app the app is broken into "modules" where as microservice break as services(mini application)..


What Microservices offers?

1.Microservices offers "form of modularity"
2.Each service has its own database - Customer Service may use "Mongodb'
  where as payment service may use "Oracle database"

Benefits of the microservice architecture

 It enables the continuous delivery and deployment of large, complex applications.
 Services are small and easily maintained.
 Services are independently deployable.
 Services are independently scalable.
 The microservice architecture enables teams to be autonomous.
 It allows easy experimenting and adoption of new technologies.
 It has better fault isolation
....................................................................................
			How to design and implment microservices

The microservices is all about practices followed,implemented, and tested in real time production grade applications in various companies like amazon,netflix,google,microsoft.

The many community people joined  togther who formed the pattern language in order to begin development of Microservices - Microservice pattern language, design patterns
.....................................................................................
	      Decision Pointers when start building app


Step : 0 - May be for new Application(new Requirement) or existing Application
			
Requriment for building online food delivery:
	
1.You are developing a server-side enterprise application.

2.It must support a variety of different clients including desktop browsers, mobile browsers and native mobile applications. 

3.The application might also expose an API for 3rd parties to consume.

4.It might also integrate with other applications via either web services or a message broker.

5.The application handles requests (HTTP requests and messages) by executing business logic; accessing a database; exchanging messages with other systems; and returning a HTML/JSON/XML response. 

6.There are logical components corresponding to different functional areas of the application.	

			  Pattern Languages
.....................................................................................

Pattern is a resuable soultion to  a problem that occurs in a particular context.

Christopher Alexander writings inspired the software community to adopt the concept of patterns and patterns language, The book Design patterns: Elements of Resuable Object oriented Sofware - GOF patterns.


Elements of patterns.

Every Pattern has sections

1.Forces
2.Result Context
3.Related patterns

Forces: The issues that you must address when  sovling a problem.

 The forces section of a pattern describes the forces(issues) that you must address when solving a problem in a given context.

Sometimes forces can conflict, so it might not be possible to solve all of them.

Which issues(forces) are more important dependens on the context.

eg:

When you write code in a reactive style , has better performance than non reactive sync code.
But it more difficult to understand.

Resulting Context:
..................
 The force section of a pattern describes issues(forces) that must address when a solving a problem in a given context.

The result context section of a pattern describes the consequences(advantages and disadvantages) of applying the pattern.

It consists of three parts

1.Benefits: 
   The benefits of the pattern, including the forces that have been resolved.
2.Drawbacks:
   The drawbacks of the pattern, including, un resolved forces.
3.Issues
    The new Problems that have been introduced by applying the pattern.

The resulting context provides a more complete and less biased view of the solution
which enables better decisions.

Related Patterns:
 The related patterns describe the relationship between the pattern and other patterns.


There are five types of relationship between patterns.

Predecessor – a predecessor pattern is a pattern that motivates the need for this pattern. For example, the Microservice Architecture pattern is the predecessor to the rest of the patterns in the pattern language except the monolithic architecture pattern

if i have selected microservice, then only i can think about other patterns of microserivce else i cant.

Successor – a pattern that solves an issue that is introduced by this pattern. 
For example, if you apply the Microservice Architecture pattern you must then apply numerous successor patterns including service discovery patterns and the Circuit Breaker pattern.

Alternative – a pattern that provides an alternative solution to this pattern. For example, the Monolithic Architecture pattern and the Microservice Architecture pattern are alternative ways of architecting an application. You pick one or the other.

Generalization: - A Pattern that is a general soultion to a problem for eg if you want to host a service , we have different implementations like single serivce per host pattern, single service on multiple hosting etc...

Specialiation: - A specialized form of  a particular pattern -  For eg deploy a service as container pattern is spacilzation of a single service per host.
.....................................................................................
....................................................................................
		   Microservice arichitecture pattern language
...................................................................................  
The Microservice pattern language is a collection of patterns that help you architect an application using the microservice architectures.

Infrastructure Patterns:
  Thses solves problems that are mostly infrastructure issues outside of development.

Application patterns:
  These are for related to development

Application Infrastructure:
   Application related infrastructures like containers
.....................................................................................
....................................................................................
		 Patterns for Decomposing an Application into services	


1.Decompose by business capability 
	 |
	 |
2.Decompose by subdomain

3.SelfContained Service

4.Service Per Team
.....................................................................................
			    Design patterns in Microservices
....................................................................................

Application Architecture Pattern
   For building n-tier client server distributed application.

-Monolithic architecture
-Microservice architecture

Decomposition Pattern -Y scalling

1.Decompose by business capability 	 
2.Decompose by subdomain
3.SelfContained Service
4.Service Per Team


MicroService Architecture Pattern------>Depcompostion Pattern

Decompose by business capability 

If you are going to build online store.

Business capability:
Product Catalog Management
Inventory Management
Order Management
Delivery Management.

Alternate Pattern

Decompose by SubDomain:
 Decompose the problem based on DDD principles.

....................................................................................
				Data Management
....................................................................................

Core Pattern:
1.Database Per Service Pattern
2.Shared Database

Note:
  if you take any data related patterns, "Transactions" are very important.


1.Database Per Service Pattern leads/succeeds other patterns
  Domain Event
  Event Sourcing 
  Saga - Transaction
  CQRS
  API Composition
 
..................................................................................
	    Advance Data Management Pattern -Transactional Messaging Pattern   
..................................................................................

1.Transactional outbox
    2.Transactional log tailing
     or
    3.Polling publisher

   2.1.Idemponent Consumer
.....................................................................................
			Communication Style Patterns
...................................................................................

Service = Mini Application

MiniApplication = Collection of Programs

Collection of programs in Java = Collections of classes

Collections of classes = Collections Objects.

Object/Class = Collection of  state and behaviour

State = data
Behaviour=methods

Object = methods

methods = API

API will DO three things

1.write - update,remove,insert
2.read
3.process

class OrderService {

   @Autowrited
   private OrderRepository orderRepo;
   //API
   public List<Order> findAll(){
	orderRepo.findAll()
   }
 
}

Types of API:
1.local api
   api which are called with in same runtime by other apis
2.remote api
  api which are called outside runtime via networks 

How to build remote api?

 Based on protocals

1.HTTP Protocal.

 if you design your api based on HTTP protcal, those apis are called as "WebServices"

Web Service:
  RESTFull WebServices,SOAP WebServices

REST API = Program

In java => classes

In Web Services classes are called "End Points"

In Micro services -Services can be  represented as "WebServices"

Rest WebService------>http-----RestWebservice => HTTP based Microservice

Rest WebService------>http-----Graphql => HTTP based Microservice

Rest WebService------>http/2 over tcp------GRpc Service=> TCP based Microservice

Rest Web Service ---->TCP/MOM-------------->Messaging Service -Middlewares

Communication Sytle patterns:

1.RPI patterns
   REST,gRPC,Apache Thrift - RPI implementations
2.Messaging
   Any Messaging middlewares - RabbitMQ,IBM MQ,MicroSoft MQ - MQTT,AMQP
   Streaming platforms - Apache Kafka,Confluent Kafka
   2.1.Idemponent Consumer
3.Domain Specfic Protocal
   SMTP - Mail Service   

.....................................................................................
			   Deployment Patterns
.....................................................................................

Once the services(applications) are ready, we can move the application into production.

Production Related Patterns:

Deployment Environment/Plattforms

1.Bare Metal 
    Where as physical hardware, and operating system, Where we can provision our application.
    If you deploy java application.

  OS: Linux
  JRE- 17
  WebContainer -Tomcat
  Databases -MySql
  Streaming Platforms-Kafka
   
2.Virutal Machine 
   Oracle Virtual box 
    on VM , you can install os-linux
  JRE- 17
   WebContainer -Tomcat
   Databases -MySql
   Streaming Platforms-Kafka

3.Containerized Deployment
    It is lightweight vm - Docker and Kubernets
   JRE- 17
   WebContainer -Tomcat
   Databases -MySql
   Streaming Platforms-Kafka
  
4.Cloud 
   ->VM /container/bare 
  you can just deploy your app only,
  cloud may give you all softwares for you...


  "Cloud with containers are most preferable deployment for microservices"

Design patterns:

Bare Metal:
 1.Multiple services instances per host
 2.Service instance per host
VM
 1.Service instance Per VM
Container
 1.Service instance per Container
Cloud
 1.server less deployment
 2.Service deployment platform
 3.container and cloud

			      
		if your app deployement is in container 
				  or 
    			       in cloud
				  or 
			   Container with cloud
				 or 
			   in any Virtualized Env

if any micro service(application) is running in containerized env like kubernets(docker).

Challanges:
 1.suppose the application is accessed by other application or external application
   we need to communicate the application with help of "host:port".
 if application is running Virtualized env, "host and port" is not static,it would be dynamic.

 if it is dynamic then how other microservices, and external application, how they can communicate.
			
To solve the problem of identifying the services which are running in Virtualized env
 
				Advanced Communication Patterns
				(Service Registry and Discovery)


When we apply this pattern, services never communicate "directly", because they dont know each other due to "dynamic location",so they use broker to communicate, broker will have all service information-Service Registry

Service Registry Patterns:

1.Client side service Discovery
2.Server-side service Discovery
   ->Service Registry
  	->Self Registration
   	->ThridParty Registration

.....................................................................................
                     Services are running in Virtualized Env
		     Services are talking via Service Registry
		What if i any service is down / Slow / Throwing Exception
					
Microservices provides a Design patterns to handle failures and slow calls

			 Service Reliablity Patterns

1.Timeout Pattern
2.Bulk Head Pattern
3.Retry Pattern
4.Circuit Breaker Patterns
.....................................................................................
			    Configuration Data and Its patterns

Every application which requires configuration data,the configuration data may be connection strings,api tokens,application settings etc...

In Java application, configuration data is kept inside properties or yml files...

What if in micro serivces, the configuration is need to be shared across the application?

We have design pattern to centeralize configuration data/information.

1.Microservice Chassis
2.Service Templates
3.Externalized COnfiguration
.....................................................................................
		   Micro services are ready in production
			Now we need to expose to
		 other Applications- User interface applications

Microservices provide you a design pattern, called

External API patterns:

1.API Gate ways
  2.Back End for FrontEnd

.....................................................................................
		     Micro services are ready in production
		We have exposed our microservices via API Gateways
			  How to secure them?

Security Patterns

1.Access Tokens
   -Authentecation
   -Authrozation
   -SSL
   -Policies
....................................................................................
			Now your Micro service is in Production
				Next what should i do
			     Your App in Maintaince 

Monitor Your apps......

Observablity Design patterns:

1.Log Management/Aggregation Pattern
2.Application Metrics Pattern
3.Audit Logging pattern
4.Distributed Tracing
5.Exception Tracker Pattern
6.Health Check API pattern
.....................................................................................
			How to apply/select pattern
.....................................................................................

Pattern Elements

1.Context
2.Problem
3.Forces
4.Solution
5.Resulting Context
6.Related Patterns
7.Anti patterns
8.Implementation using program - Spring.
.....................................................................................
			Microservices Implementations
.....................................................................................

Microservices are language independant.
You can build microservices in any language.

Implementations:

1.java
   -Spring cloud (spring framwork)
   -Quarkus
   -Ecplise Vertx
  Scala
    -Play
 etc....

2.javascript
  -Nest.js
  -Molculer
  -Loopback
.....................................................................................
				Moleculer
.....................................................................................

What is Moleculer?

Moleculer is node.js framework for building microservices application.
Moleculer implements most of the design patterns of microservices.

Features of Moleculer:

1.Promise-based solution (async/await compatible)
2.request-reply concept
3.support event driven architecture with balancing
4.built-in service registry & dynamic service discovery
5.load balanced requests & events (round-robin, random, cpu-usage, latency, sharding)
6.many fault tolerance features (Circuit Breaker, Bulkhead, Retry, Timeout, Fallback)
plugin/middleware system
7.support versioned services
8.support Streams
9.service mixins
10.built-in caching solution (Memory, MemoryLRU, Redis)
11.pluggable loggers (Console, File, Pino, Bunyan, Winston, Debug, Datadog, Log4js)
12.pluggable transporters (TCP, NATS, MQTT, Redis, NATS Streaming, Kafka, AMQP 0.9, AMQP 1.0)
13.pluggable serializers (JSON, Avro, MsgPack, Protocol Buffer, Thrift)
14.pluggable parameter validator
15.multiple services on a node/server
16.master-less architecture, all nodes are equal
17.parameter validation with fastest-validator
18.built-in metrics feature with reporters (Console, CSV, Datadog, Event, Prometheus, StatsD)
19.built-in tracing feature with exporters (Console, Datadog, Event, Jaeger, Zipkin)
20.official API gateway, Database access and many other modules…

core concepts:

1.Service

 A service is a simple JavaScript module containing some part of a complex application. 
 A service represents a biz logic in your application.


2.Service Broker : == Spring Container

 Service Broker is the heart of Moleculer.

It is responsible for management and communication between services (local and remote). 

3.node :
 A node is a simple OS process running on a local or external network.
 A single instance of a node can host one or many services.
 node js platform - v8+libvu..

Each node must have an instance of Service Broker.

"Service Broker is one single Node instance - Node runtime"

4.Transporter
	Transporter is a communication bus that services use to exchange messages. 
 It transfers events, requests and responses.

5.Gateway
     API Gateway exposes Moleculer services to end-users.
 The gateway is a regular Moleculer service running a (HTTP, WebSockets, etc.) server. It handles the incoming requests, maps them into service calls, and then returns appropriate responses.
.....................................................................................
			Coding -Getting started


Service Types:


1.Back end services - It is not exposed as "REST" API
2.Front end Services  -It is rest apis.

Project setup :

1.using tool moleculr cli tool
2.without using any tool.

Project creation:
.................
>mkdir basic-app
>cd basic-app

>mkdir services
>npm install moleculer --save

How to create service broker,declare service and start?

const { ServiceBroker } = require('moleculer')

//create service broker object
const broker = new ServiceBroker()

//create service
broker.createService({
    name: 'hello',
    actions: {
        //apis
        sayHello() {
            return "Hello"
        }
    }
})

async function main() {
    // broker.start().then(() => {
    //     console.log('broker is ready')
    //     //call service.
    //     broker.call('hello.sayHello').then(res => {
    //         console.log(res)
    //     }).catch(err => {
    //         console.log(err)
    //     })
    // }).catch(err => {
    //     console.log('Server failed')
    // })
    try {
        await broker.start()
        console.log('broker is ready')
        const res = await broker.call('hello.sayHello')
        console.log(res)
    }
    catch (err) {
        console.log(err)
    }

}
main()
...

Multi Methods:
const { ServiceBroker } = require('moleculer')

//create broker object 
const broker = new ServiceBroker()

//create service 
broker.createService({
    name: 'greeter', //service Name
    actions: {
        //service apis
        sayHello() {
            return 'Hello Micro service'
        },
        sayHai() {
            return 'Hai Micro Service'
        },
        sayGreet() {
            return 'Welcome to Microservices'
        }
    }
})
//deploy the service on Broker(Server)
async function main() {
    //start server
    try {
        await broker.start()
        console.log('Service is ready')
        //call service api 
        const hello = await broker.call('greeter.sayHello')
        const hai = await broker.call('greeter.sayHai')
        const greeter = await broker.call('greeter.sayGreet')
        console.log(hello, hai, greeter)
    }
    catch (err) {

    }
}
main()
...............................................................................

Multi Service:
const { ServiceBroker } = require('moleculer')

//create broker object 
const broker = new ServiceBroker()

//create service 
broker.createService({
    name: 'customer', //service Name
    actions: {
        findAll() {
            return [{
                id: 1,
                name: 'abc pvt ltd',
                address: {
                    city: 'HYD'
                }
            }]
        }
    }
})

broker.createService({
    name: 'products',
    actions: {
        findAll() {
            return [{ id: 1, name: 'Phone', qty: 100, price:1000 }]
        }
    }
})
//deploy the service on Broker(Server)
async function main() {
    //start server
    try {
        await broker.start()
        console.log('Service is ready')
        const customer = await broker.call('customer.findAll')
        const products = await broker.call('products.findAll')
        console.log(customer)
        console.log(products)
    }
    catch (err) {
        console.log(err)
    }
}
main()
..........

			    Service api parameters
....................................................................................

How to pass params to Service methods? How to read args from the service Method?

Parameters are stored inside special object called "Context"

Context Object:

1.Similar to Broker Object
2.It has all capacity of Broker object
3.Context object is used inside service definitions , where ever you require broker
  Object reference.

context object already created, and its refernce is avaiable inside "Service method" as args.

reading parameters

1.context.params 
  params are literal object what ever parameter we pass, it will inside this

context.params.variable


const { ServiceBroker } = require('moleculer')

//create broker object 
const broker = new ServiceBroker()

//create service 
broker.createService({
    name: 'math', //service Name
    actions: {
        add(ctx) {
            console.log(ctx.params)
            const { a, b } = ctx.params
            return a + b
        }
    }
})


//deploy the service on Broker(Server)
async function main() {
    //start server
    try {
        await broker.start()
        console.log('Service is ready')
        const res= await broker.call('math.add', { a: 10, b: 20 })
        console.log(res)
    }
    catch (err) {
        console.log(err)
    }
}
main()

Error Response:
..............

code: 422,
  type: 'VALIDATION_ERROR',
  data: [
    {
      type: 'number',
      message: "The 'a' field must be a number.",
      field: 'a',
      actual: 'abc',
      nodeID: 'desktop-kaufcr7-15032',
      action: 'math.add'
    }
  ],
  retryable
.....................................................................................
....................................................................................
		    Dynamic Parameters and dynamic invocation of services
...................................................................................

Moleculer has a tool called "Moleculer REPL"
>npm install moleculer-repl --save-dev



const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker()

broker.createService({
    name: 'math',
    actions: {
        divide: {
            //param validation logic
            params: {
                a: "number",
                b: "number"
            },
            //biz logic 
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                return a / b
            }
        }
    }
})


async function main() {
    try {
        //start the broker 
        await broker.start()
        //use repl prompt
        broker.repl()
   
    } catch (err) {
        console.log(err)
    }
}
main()

mol $ call math.divide --a 10000 --b 234
>> Call 'math.divide' with params: { a: 10000, b: 234 } with meta: { '$repl': true } with options: {}
>> Execution time:4ms
>> Response:
42.73504273504273
.....................................................................................
			     Service Communication
.....................................................................................

Service Representation:

1.RPI
  -REST,Graphql
  -Grpc
  -Thirft
2.Messaging 
  -RabbitMQ
  -Kafka

RPI
 Rest to Rest Communication
 Rest to TCP/non Rest communication.


Moleculr supports all types of communications

1.NonRest to NonRest Communication - BackEndService to BackEndService

Moleculer is microservice, generally microservices may be distributed across multiple machines(nodes) , which communicates via networks.
.......................

1.Service communication with in single broker - local services

2.Service communication across multiple service brokers -remote services


Communication style

1. can be sync
2. can be async

Types of services:

1.local service
   service which is implemented on single broker.
2.remote service
   Service which is implemented across the brokers.
 
Services can communicate within service broker-single node arch
Services can communicate across service brokers - multi node arch

How services are interacting each other?

 Using "Context" Object


Actors:

 1.Caller service, who is calling /consuming other services

 2.Callee service, who is called by others

....................................................................................

Use case: RPC TO RPC , within single Broker(Single Node)
........................................................
const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker()


//service 1
broker.createService({
    name: 'math',
    actions: {
        add(ctx) {
            return ctx.params.a + ctx.params.b
        }
    }
})

//service 2
broker.createService({
    name: 'calculator',
    actions: {
        add(ctx) {
            //need to call math
            const { a, b } = ctx.params
            return ctx.call('math.add', { a, b })
        }
    }
})


async function main() {
    try {
        //start the broker 
        await broker.start()
        //use repl prompt
        broker.repl()

    } catch (err) {
        console.log(err)
    }
}
main()
....................................................................................
Multi Node


Project setup:

we have to create two app.

G:\IBM\2024\May\Nodejs\microservices\communication\multinode>mkdir math

G:\IBM\2024\May\Nodejs\microservices\communication\multinode>mkdir calculator

G:\IBM\2024\May\Nodejs\microservices\communication\multinode>cd math

G:\IBM\2024\May\Nodejs\microservices\communication\multinode\math>npm init --yes
W
G:\IBM\2024\May\Nodejs\microservices\communication\multinode\math>npm install moleculer --save

G:\IBM\2024\May\Nodejs\microservices\communication\multinode\math>npm install moleculer-repl --save-dev

Repeat the same step for calculator.

services/calculator.service.js
const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker()

broker.createService({
    name: 'calculator',
    actions: {
        add(ctx) {
            //need to call math
            const { a, b } = ctx.params
            return ctx.call('math.add', { a, b })
        }
    }
})


async function main() {
    try {
        //start the broker 
        await broker.start()
        //use repl prompt
        broker.repl()

    } catch (err) {
        console.log(err)
    }
}
main()

services/math.service.js

const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker()


//service 1
broker.createService({
    name: 'math',
    actions: {
        add(ctx) {
            return ctx.params.a + ctx.params.b
        }
    }
})



async function main() {
    try {
        //start the broker 
        await broker.start()
        //use repl prompt
        broker.repl()

    } catch (err) {
        console.log(err)
    }
}
main()

After running:

 call calculator.add --a 10 --b 20

>> ERROR:
ServiceNotFoundError: Service 'math.add' is not found.
    at ServiceBroker.findNextActionEndpoint (G:\IBM\2024\May\Nodejs\microservices\communication\multinode\calculator\node_modules\moleculer\src\service-broker.js:1164:13)
    at ServiceBroker.call (G:\IBM\2024\May\Nodejs\microservices\communication\multinode\calculator\node_modules\moleculer\src\service-broker.js:1213:26)
    at Context.call (G:\IBM\2024\May\Nodejs\microservices\communication\multinode\calculator\node_modules\moleculer\src\context.js:286:23)
    at Service.add (G:\IBM\2024\May\Nodejs\microservices\communication\multinode\calculator\services\calculator.service.js:11:24)
    at G:\IBM\2024\May\Nodejs\microservices\communication\multinode\calculator\node_modules\moleculer\src\utils.js:212:22
    at ServiceBroker.timeoutMiddleware (G:\IBM\2024\May\Nodejs\microservices\communication\multinode\calculator\node_modules\moleculer\src\middlewares\timeout.js:31:14)
    at ServiceBroker.fallbackMiddleware (G:\IBM\2024\May\Nodejs\microservices\communication\multinode\calculator\node_modules\moleculer\src\middlewares\fallback.js:31:11)
    at ServiceBroker.errorHandlerMiddleware (G:\IBM\2024\May\Nodejs\microservices\communication\multinode\calculator\node_modules\moleculer\src\middlewares\error-handler.js:14:10)
    at ServiceBroker.call (G:\IBM\2024\May\Nodejs\microservices\communication\multinode\calculator\node_modules\moleculer\src\service-broker.js:1237:31)
    at handler (G:\IBM\2024\May\Nodejs\microservices\communication\multinode\calculator\node_modules\moleculer-repl\src\commands\call.js:162:28)

Why this error?

=>moleculer by default looks the services within the same broker, if it is not available
within the current broker it will try to connect other brokers.

			 How brokers can talk each other?

Networking:
..........
in order to communicate with other nodes(servicebrokers) you need to configure a "Transporter"

Transporter:
 It is a bus which transports, calls,messages,events....

Transporter connected via a centeral Message broker that provides a reliable way of exchanging messages among remote nodes.


-Transporter is an important module if you are running services on multiple nodes. 

-Transporter communicates with other nodes. 

-It transfers events, calls requests and processes responses …etc. 

-If a service runs on multiple instances on different nodes, the requests will be load-balanced among live nodes.

 How brokers can talk each other?

Networking:
..........
in order to communicate with other nodes(servicebrokers) you need to configure a "Transporter"

Transporter:
 It is a bus which transports, calls,messages,events....

Transporter connected via a centeral Message broker that provides a reliable way of exchanging messages among remote nodes.


-Transporter is an important module if you are running services on multiple nodes. 

-Transporter communicates with other nodes. 

-It transfers events, calls requests and processes responses …etc. 

-If a service runs on multiple instances on different nodes, the requests will be load-balanced among live nodes.


Transports:
............

Built-in transporter

TCP transporter - part of moleculer
Third party Message Brokers
NATS Transporter
Redis Transporter
MQTT Transporter
AMQP Transporter
Kafka Transporter
NATS Streaming (STAN) Transporter
Custom Transporter

TCP transporter:

This is a no-dependency, zero-configuration TCP transporter.
It uses Gossip protocol to disseminate node statuses, service list and heartbeats.
It contains an integrated UDP discovery feature to detect new and disconnected nodes on the network.
If the UDP is prohibited on your network, use urls option. It is a list of remote endpoints (host/ip, port, nodeID). It can be a static list in your configuration or a file path which contains the list.

Use case :How to use TCP transport as channel for service Communications.

We need to configure Service Broker to enable transporter.

ServiceBroker object creation:

const broker = new ServiceBroker();
 Here we have not passed any parameter to ServiceBroker Constructor, if you dont, the default parameters will be passed.

Service Broker Parameters are called as "ServiceBroker Schema"

We can override service Broker Schema to enable broker vide features.




Use case :How to use TCP transport as channel for service Communications.

We need to configure Service Broker to enable transporter.

ServiceBroker object creation:

const broker = new ServiceBroker();
 Here we have not passed any parameter to ServiceBroker Constructor, if you dont, the default parameters will be passed.

Service Broker Parameters are called as "ServiceBroker Schema"

We can override service Broker Schema to enable broker vide features.

const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker({
    transporter:"TCP"
});

eg:
App1
const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker({
    transporter:"TCP"
})

broker.createService({
    name: 'math',
    actions: {
        add: {
            //param validation logic
            params: {
                a: "number",
                b: "number"
            },
            //biz logic 
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                //service to service communication via context object 
                return ctx.call('adder.add', { a: a, b: b })
            }
        },
        multiply: {
            //param validation logic
            params: {
                a: "number",
                b: "number"
            },
            //biz logic 
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                //service to service communication via context object 
                return ctx.call('multiplier.multiply', { a: a, b: b })
            }
        },
    }
})

broker.createService({
    name: 'adder',
    actions: {
        add: {
            //param validation logic
            params: {
                a: "number",
                b: "number"
            },
            //biz logic 
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                return a + b
            }
        }
    }
})


async function main() {
    try {
        //start the broker 
        await broker.start()
        //use repl prompt
        broker.repl()

    } catch (err) {
        console.log(err)
    }
}
main()

App2
const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker({
    transporter: "TCP"
})

broker.createService({
    name: 'multiplier',
    actions: {
        multiply: {
            //param validation logic
            params: {
                a: "number",
                b: "number"
            },
            //biz logic 
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                return a * b
            }
        }
    }
})



async function main() {
    try {
        //start the broker 
        await broker.start()
        //use repl prompt
        broker.repl()

    } catch (err) {
        console.log(err)
    }
}
main()

Testing

Node1
node services/math.service.js
[2022-11-10T05:20:16.175Z] INFO  laptop-r2tggfdl-82848/BROKER: Moleculer v0.14.26 is starting...
[2022-11-10T05:20:16.177Z] INFO  laptop-r2tggfdl-82848/BROKER: Namespace: <not defined>
[2022-11-10T05:20:16.177Z] INFO  laptop-r2tggfdl-82848/BROKER: Node ID: laptop-r2tggfdl-82848
[2022-11-10T05:20:16.179Z] INFO  laptop-r2tggfdl-82848/REGISTRY: Strategy: RoundRobinStrategy
[2022-11-10T05:20:16.179Z] INFO  laptop-r2tggfdl-82848/REGISTRY: Discoverer: LocalDiscoverer
[2022-11-10T05:20:16.186Z] INFO  laptop-r2tggfdl-82848/BROKER: Serializer: JSONSerializer
[2022-11-10T05:20:16.198Z] INFO  laptop-r2tggfdl-82848/BROKER: Validator: FastestValidator
[2022-11-10T05:20:16.200Z] INFO  laptop-r2tggfdl-82848/BROKER: Registered 13 middleware(s).
[2022-11-10T05:20:16.202Z] INFO  laptop-r2tggfdl-82848/BROKER: Transporter: TcpTransporter
[2022-11-10T05:20:16.215Z] INFO  laptop-r2tggfdl-82848/TRANSIT: Connecting to the transporter...
[2022-11-10T05:20:16.218Z] INFO  laptop-r2tggfdl-82848/TRANSPORTER: TCP server is listening on port 51606
[2022-11-10T05:20:16.229Z] INFO  laptop-r2tggfdl-82848/TRANSPORTER: UDP Multicast Server is listening on 172.21.112.1:4445. Membership: 239.0.0.0
[2022-11-10T05:20:16.230Z] INFO  laptop-r2tggfdl-82848/TRANSPORTER: UDP Multicast Server is listening on 172.17.64.1:4445. Membership: 239.0.0.0
[2022-11-10T05:20:16.231Z] INFO  laptop-r2tggfdl-82848/TRANSPORTER: UDP Multicast Server is listening on 192.168.1.8:4445. Membership: 239.0.0.0
[2022-11-10T05:20:16.232Z] INFO  laptop-r2tggfdl-82848/TRANSPORTER: UDP Multicast Server is listening on 127.0.0.1:4445. Membership: 239.0.0.0
[2022-11-10T05:20:16.233Z] INFO  laptop-r2tggfdl-82848/TRANSPORTER: UDP discovery started.
[2022-11-10T05:20:16.233Z] INFO  laptop-r2tggfdl-82848/TRANSPORTER: TCP Transporter started.
[2022-11-10T05:20:16.739Z] INFO  laptop-r2tggfdl-82848/REGISTRY: '$node' service is registered.
[2022-11-10T05:20:16.741Z] INFO  laptop-r2tggfdl-82848/REGISTRY: 'math' service is registered.
[2022-11-10T05:20:16.743Z] INFO  laptop-r2tggfdl-82848/REGISTRY: 'adder' service is registered.
[2022-11-10T05:20:16.743Z] INFO  laptop-r2tggfdl-82848/$NODE: Service '$node' started.
[2022-11-10T05:20:16.744Z] INFO  laptop-r2tggfdl-82848/MATH: Service 'math' started.
[2022-11-10T05:20:16.745Z] INFO  laptop-r2tggfdl-82848/ADDER: Service 'adder' started.
[2022-11-10T05:20:16.745Z] INFO  laptop-r2tggfdl-82848/BROKER: ✔ ServiceBroker with 3 service(s) started successfully in 530ms.
mol $ [2022-11-10T05:20:52.460Z] INFO  laptop-r2tggfdl-82848/REGISTRY: Node 'laptop-r2tggfdl-53460' reconnected.
mol $ nodes
╔═══════════════════════════╤══════════╤═════════╤════════╤════════════════════╤══════════╤════════════════════════════╗
║ Node ID                   │ Services │ Version │ Client │ IP                 │    State │ CPU                        ║
╟───────────────────────────┼──────────┼─────────┼────────┼────────────────────┼──────────┼────────────────────────────╢
║ laptop-r2tggfdl-53460     │ 2        │ 0.14.26 │ nodejs │ 172.21.112.1  (+2) │  ONLINE  │ [■■■.................] 14% ║
║ laptop-r2tggfdl-82848 (*) │ 3        │ 0.14.26 │ nodejs │ 172.21.112.1  (+2) │  ONLINE  │ [■...................] 4%  ║
╚═══════════════════════════╧══════════╧═════════╧════════╧════════════════════╧══════════╧════════════════════════════╝
..............................

Node 2:
node services/multiplier.service.js
[2022-11-10T05:20:49.701Z] INFO  laptop-r2tggfdl-53460/BROKER: Moleculer v0.14.26 is starting...
[2022-11-10T05:20:49.702Z] INFO  laptop-r2tggfdl-53460/BROKER: Namespace: <not defined>
[2022-11-10T05:20:49.703Z] INFO  laptop-r2tggfdl-53460/BROKER: Node ID: laptop-r2tggfdl-53460
[2022-11-10T05:20:49.704Z] INFO  laptop-r2tggfdl-53460/REGISTRY: Strategy: RoundRobinStrategy
[2022-11-10T05:20:49.705Z] INFO  laptop-r2tggfdl-53460/REGISTRY: Discoverer: LocalDiscoverer
[2022-11-10T05:20:49.711Z] INFO  laptop-r2tggfdl-53460/BROKER: Serializer: JSONSerializer
[2022-11-10T05:20:49.721Z] INFO  laptop-r2tggfdl-53460/BROKER: Validator: FastestValidator
[2022-11-10T05:20:49.723Z] INFO  laptop-r2tggfdl-53460/BROKER: Registered 13 middleware(s).
[2022-11-10T05:20:49.725Z] INFO  laptop-r2tggfdl-53460/BROKER: Transporter: TcpTransporter
[2022-11-10T05:20:49.736Z] INFO  laptop-r2tggfdl-53460/TRANSIT: Connecting to the transporter...
[2022-11-10T05:20:49.739Z] INFO  laptop-r2tggfdl-53460/TRANSPORTER: TCP server is listening on port 51607
[2022-11-10T05:20:49.756Z] INFO  laptop-r2tggfdl-53460/TRANSPORTER: UDP Multicast Server is listening on 172.21.112.1:4445. Membership: 239.0.0.0
[2022-11-10T05:20:49.757Z] INFO  laptop-r2tggfdl-53460/TRANSPORTER: UDP Multicast Server is listening on 172.17.64.1:4445. Membership: 239.0.0.0
[2022-11-10T05:20:49.760Z] INFO  laptop-r2tggfdl-53460/TRANSPORTER: UDP Multicast Server is listening on 192.168.1.8:4445. Membership: 239.0.0.0
[2022-11-10T05:20:49.761Z] INFO  laptop-r2tggfdl-53460/TRANSPORTER: UDP Multicast Server is listening on 127.0.0.1:4445. Membership: 239.0.0.0
[2022-11-10T05:20:49.764Z] INFO  laptop-r2tggfdl-53460/TRANSPORTER: UDP discovery started.
[2022-11-10T05:20:49.766Z] INFO  laptop-r2tggfdl-53460/TRANSPORTER: TCP Transporter started.
[2022-11-10T05:20:50.289Z] INFO  laptop-r2tggfdl-53460/REGISTRY: '$node' service is registered.
[2022-11-10T05:20:50.290Z] INFO  laptop-r2tggfdl-53460/REGISTRY: 'multiplier' service is registered.
[2022-11-10T05:20:50.293Z] INFO  laptop-r2tggfdl-53460/$NODE: Service '$node' started.
[2022-11-10T05:20:50.299Z] INFO  laptop-r2tggfdl-53460/MULTIPLIER: Service 'multiplier' started.
[2022-11-10T05:20:50.301Z] INFO  laptop-r2tggfdl-53460/BROKER: ✔ ServiceBroker with 2 service(s) started successfully in 564ms.
mol $ [2022-11-10T05:20:53.977Z] INFO  laptop-r2tggfdl-53460/REGISTRY: Node 'laptop-r2tggfdl-82848' reconnected.

mol $ nodes
╔═══════════════════════════╤══════════╤═════════╤════════╤════════════════════╤══════════╤════════════════════════════╗
║ Node ID                   │ Services │ Version │ Client │ IP                 │    State │ CPU                        ║
╟───────────────────────────┼──────────┼─────────┼────────┼────────────────────┼──────────┼────────────────────────────╢
║ laptop-r2tggfdl-53460 (*) │ 2        │ 0.14.26 │ nodejs │ 172.21.112.1  (+2) │  ONLINE  │ [■■■.................] 15% ║
║ laptop-r2tggfdl-82848     │ 3        │ 0.14.26 │ nodejs │ 172.21.112.1  (+2) │  ONLINE  │ [■■..................] 11% ║
╚═══════════════════════════╧══════════╧═════════╧════════╧════════════════════╧══════════╧════════════════════════════╝

mol $

.....................................................................................
.............................................................................................
			  How to use other Message Brokers
.....................................................................................

Steps:
1.You need a message broker software -  redis,nats,rabbitmq...

docker run  --name nats-main -p 4222:4222 -p 6222:6222 -p 8222:8222 nats

2.you need to install driver for connecting third message broker.
 
incase of nat
 npm install nats --save

3.configure in the service broker

const broker = new ServiceBroker({
    transporter:"nats://localhost:4222"
})
.....................................................................................
.....................................................................................
.....................................................................................
.....................................................................................
.....................................................................................

				Methods Types

/////////////////////////////////////////////////////////////////////////////////////////////

Service Methods:

1.public methods
    methods are accssiable outside 
2.private methods
  methods are not accssible outside
  methods are used to isloate complex logic from public methods.


3.life cycles methods
  Life cycles methods are called by broker automatically

 Types of life cycle methods:

1.broker life cycle method

    created(broker) {},

    started(broker) {},

    stopped(broker) {}
2.service life cycle method
  created() {
        // Fired when the service instance created (with `broker.loadService` or `broker.createService`)
    },

    merged() {
        // Fired after the service schemas merged and before the service instance created
    },
    
    async started() {
        // Fired when broker starts this service (in `broker.start()`)
    }

    async stopped() {
        // Fired when broker stops this service (in `broker.stop()`)
    }



public methods:
 any thing if you write inside actions are called public methods.

actions: { 
   
  //public methods
  sayHello:{
     handler(ctx){

      }
  }

}

private methods:

createService({

 //public methods
 actions: {

 },

 //private methods
 methods: {


 }

})


const { ServiceBroker } = require('moleculer')
//create broker object 
const broker = new ServiceBroker()

broker.createService({
    name: 'math', //service Name
    actions: {
        add: {
            //meta information
            params: {
                a: {
                    type: 'number',
                    positive: true,
                    integer: true
                },
                b: {
                    type: 'number',
                    positive: true,
                    integer: true
                }
            },
            //logic
            handler(ctx) {
                //return ctx.params.a + ctx.params.b
                return this.add(ctx.params.a, ctx.params.b)
            }
        }
    },
    methods: {
        //private methods
        add(a = 0, b = 0) {
            return a + b
        }
    }
})

//deploy the service on Broker(Server)
async function main() {
    //start server
    try {
        await broker.start()
        broker.repl()
    }
    catch (err) {
        console.log(err)
    }
}
main()
.........
const { ServiceBroker } = require('moleculer')
//create broker object 
const broker = new ServiceBroker()

broker.createService({
    name: 'math', //service Name
    actions: {
        add: {
            //meta information
            params: {
                a: {
                    type: 'number',
                    positive: true,
                    integer: true
                },
                b: {
                    type: 'number',
                    positive: true,
                    integer: true
                }
            },
            //logic
            handler(ctx) {
                //return ctx.params.a + ctx.params.b
                return this.add(ctx.params.a, ctx.params.b)
            }
        }
    },
    methods: {
        //private methods
        add(a = 0, b = 0) {
            return a + b
        }
    },
    //life cycle methods
    created() {
        console.log('service is created')
    },
    merged() {
        console.log('service is merged')
    },
    async started() {
        console.log('service is started ')
    },
    async stoped() {
        console.log('service is stopped')
    }
})

//deploy the service on Broker(Server)
async function main() {
    //start server
    try {
        await broker.start()
        broker.repl()
    }
    catch (err) {
        console.log(err)
    }
}
main()
.....................................................................................
....................................................................................
			 Service Code Reuse- Service Inheritance
....................................................................................

A Service has many options, those options may be repeated in many other services,
like common settings.

We can isloate common features / options into a separate service, we can reuse across multiple services -  Inheritance.

How to implement inheritance in moleculer?

Javascript can support only single inheritance, only one parent allowed for a child.

Java like languages support interfaces for multi parent patterns, javascript has no such facility.

Javascript has a design pattern and implementation ,called "mixin", through mixin we can inherit many super objects.

Moleculer has mixin property

Use case:
1.if you write any REST Controller.
2.if you write database operations inside your service.
etc...

const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker();

//parent Services
const hello = {
    name: 'hello',
    actions: {
        sayHello() {
            return 'Hello,From Parent';
        }
    }
}
const hai = {
    name: 'hai',
    actions: {
        sayHai() {
            return 'Hai, From Parent'
        }
    }
}
//Child Service
broker.createService({
    name: 'greeter',
    mixins: [hello, hai]
})

async function main() {
    try {
        await broker.start()
        broker.repl();
    }
    catch (err) {
        console.log(err);
    }

}
main();

mol $ call greeter.sayHai
>> Call 'greeter.sayHai' with params: {} with meta: { '$repl': true }
>> Execution time:4ms
>> Response:
'Hai, From Parent'
mol $ call greeter.sayHello
>> Call 'greeter.sayHello' with params: {} with meta: { '$repl': true }
>> Execution time:1ms
>> Response:
'Hello,From Parent'
.....................................................................................
.....................................................................................
...................................................................................
...................................................................................
				Types of Services

Moleculer Provides two types of service

1.Custom Services
   The services are created with broker object
2.Built services
  The services are provided by Broker
 $node
   Used for administration


How to list all services using $node

 call $node.services
>> Call '$node.services' with params: {} with meta: { '$repl': true } with options: {}
>> Execution time:1ms
>> Response:
[
  {
    name: '$node',
    version: undefined,
    fullName: '$node',
    settings: {},
    metadata: {},
    local: true,
    available: true,
    nodes: [ 'laptop-r2tggfdl-17828' ]
  },
  {
    name: 'greeter',
    version: undefined,
    fullName: 'greeter',
    settings: { port: 3000, host: 'ibm.com' },
    metadata: {},
    local: true,
    available: true,
    nodes: [ 'laptop-r2tggfdl-17828' ]
  }
]

$ call $node.list
>> Call '$node.list' with params: {} with meta: { '$repl': true } with options: {}
>> Execution time:1ms
>> Response:
[
  {
    id: 'laptop-r2tggfdl-17828',
    instanceID: 'c7fd8078-2bf2-42ee-88f6-1fd20184eb3c',
    available: true,
    local: true,
    lastHeartbeatTime: 0,
    config: {},
    client: { type: 'nodejs', version: '0.14.21', langVersion: 'v16.15.0' },
    metadata: {},
    ipList: [ '172.26.240.1', '172.22.176.1', '192.168.0.105' ],
    port: null,
    hostname: 'LAPTOP-R2TGGFDL',
    udpAddress: null,
    cpu: null,
    cpuSeq: null,
    seq: 3,
    offlineSince: null
  }
]

broker.createService({})

.....................................................................................
			  Service Versioning
.....................................................................................
Each service can have version no, based on version no services can be indentified
so that the same service can be duplicated with various features.

{ 
 name:'posts'
 version:1
}
how to invoke service
v1.posts.findAll

const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker()

//declare service
broker.createService({
    name: 'posts',
    version: 1,
    actions: {
        //args
        async findAll(ctx) {
            return 'posts -v1'
        }
    }
})
broker.createService({
    name: 'posts',
    version: 2,
    actions: {
        //args
        async findAll(ctx) {
            return 'posts -v2'
        }
    }
})
async function main() {
    try {
        await broker.start()
        broker.repl()
    }
    catch (err) {
        console.log(err)
    }
}
main()

mol $ call v1.posts.findAll
>> Call 'v1.posts.findAll' with params: {} with meta: { '$repl': true }
>> Execution time:3ms
>> Response:
'posts -v1'
mol $ call v2.posts.findAll
>> Call 'v2.posts.findAll' with params: {} with meta: { '$repl': true }
>> Execution time:1ms
>> Response:
'posts -v2'
mol $
....................................................................................
....................................................................................
			 Return Data and Serialization
....................................................................................
Transporter needs a serializer module which serializes & deserializes the transferred packets. 
The default serializer is the JSONSerializer but there are several built-in serializer.

Types of Serializer:
1.JSON serializer
2.Avro serializer
3.MsgPack serializer
4.Notepack serializer
5.ProtoBuf serializer
6.Thrift serializer
7.CBOR serializer


const { ServiceBroker } = require('moleculer')
const todos = require('../mock-data/todos')


const broker = new ServiceBroker({
    serializer: "JSON"
})

//declare service
broker.createService({
    name: 'dashboard',
    actions: {
        //args
        async list(ctx) {
            const response = await ctx.call('todos.listTodos')
            return response
        }
    }
})
broker.createService({
    name: 'todos',
    actions: {
        //args
        listTodos(ctx) {
            return new this.Promise((resolve, reject) => {
                setTimeout(resolve, 5000, JSON.stringify(todos))
            })
        }
    }
})


async function main() {
    try {
        await broker.start()
        broker.repl()
    }
    catch (err) {
        console.log(err)
    }
}
main()
.....................................................................................
			 ....................................................................................
	.....................................................................................
			 ....................................................................................
			   Microservice Pattern : Data Management	
			       Database Per Service
..............................................................................................

According to Microservice pattern called "Database Per Service".

Databases supported by Moleculer:
1.Mongodb
2.mssql
3.couch
4.macrometa
5.rethink
etc....

Moleculer database Modules provides abstraction on any database layer.
Molecluer database modules provide like hibernate abstraction.


NeDb:
 In memormy and default database for Moleculer

Features:

-Default CURD operations
-Caching enabled
-pagination support
-Pluggable adapter - when even ever you want you can change database
-many adpaters supported
  -mongodb,postresql,sqllight,mysql,mssql.
-filtering supports
-encode and decode
-entity life cycle events


Steps:
1.create project
 mkdir db-app
 cd db-app
 npm init --yes
 mkdir services

npm install moleculer-db --save

npm install moleculer-db-adapter-prisma  prisma --save



npx prisma init --datasource-provider sqlite

Define Model:
schema/schema.prisma

// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Post {
  id        String   @id @default(uuid())
  title     String
  content   String?
  votes     Int
  status    Boolean
  createdAt DateTime @default(now())
}

Database Migration step:

Which creates scripts


npx prisma migrate dev

npx prisma studio

npx prisma generate


const { ServiceBroker } = require('moleculer')
const DbService = require("moleculer-db");
const PrismaAdapter = require("moleculer-db-adapter-prisma");

const broker = new ServiceBroker()


broker.createService({
    name: "posts",
    mixins: [DbService],
    adapter: new PrismaAdapter(),
    settings: {
        fields: ["id", "title", "content", "votes", "status"],
    },
    model: "post", // Model name in camelCase
});
//ui 
broker.createService({
    name: 'client',
    actions: {
        findAll(ctx) {
            const posts = ctx.call('posts.find')
            return posts
        },
        findById(ctx) {
            const { id } = ctx.params
            console.log(id)
            return ctx.call("posts.get", { id: id })

        },
        save(ctx) {
            const { title, votes, status, content } = ctx.params
            return ctx.call("posts.create", {
                title: title,
                votes: votes,
                content: content,
                status: status || false
            })
        },
        update(ctx) {
            const { id, title, votes, status, content } = ctx.params
            return ctx.call("posts.update", { id, title, votes, status, content })
        },
        remove(ctx) {
            const { id } = ctx.params
            return ctx.call("posts.remove", { id })
        }

    }
})



async function main() {
    await broker.start()
    broker.repl()
}
main()
.....................................................................................
....................................................................................
			Gatways and Restfull web services
.....................................................................................
Moleculer Modules:
..................

Moleculer core lib provides only how to create backend services, service interactions.

If i want to integrate lets say, rest api,databases, then we have to look at moleculer modules.

1.Gateways
2.Database and stores
3.Metrics & Tracing 
4.General 
5.Security
6.Tasks&Queues
7.Jobs
etc...

1.GateWay : moleculer-web:Official API Gateway for Moleculer framework.


Features:

support HTTP & HTTPS
serve static files
multiple routes
support global, route, alias middlewares
support file uploading
alias names (with named parameters & REST shorthand)
whitelist
multiple body parsers (json, urlencoded)
CORS headers
ETags
HTTP2
Rate limiter
before & after call hooks
Buffer & Stream handling
middleware mode (use as a middleware in ExpressJS Application)
support authorization and auth

npm install moleculer-web --save

basic gateway configuration:

const { ServiceBroker } = require('moleculer')
const ApiGateWay = require('moleculer-web')

const broker = new ServiceBroker()

//create gateway service 
broker.createService({
    name: 'ApiGateWay',
    mixins: [ApiGateWay]
})

async function main() {
    try {
        await broker.start()
    }
    catch (err) {
        console.log(err)
    }
}
main()

...................................................................................
			How to access back end services via GateWay
...................................................................................

const { ServiceBroker } = require('moleculer')
const ApiGateWay = require('moleculer-web')

const broker = new ServiceBroker()

//Back end Service
broker.createService({
    name: 'hello',
    actions: {
        sayHello: {
            handler(ctx) {
                return 'Hello,REST Service'
            }
        }
    }
})


//Gate Way Service
broker.createService({
    name: 'ApiGateWay',
    mixins: [ApiGateWay]
})
async function main() {
    await broker.start();
}
main();

Testing:
http://localhost:3000/serviceName/methodName

http://localhost:3000/hello/sayHello

....................................................................................
			Connecting distributed BackEnd Services

Steps:
1.Gateway service is running in a node
2.Math Service is running in another node
3.Multiplier Service is running another Node

Flow
 From the User
  http://localhost:3000/math/add?a=10&b=10


Steps:
Gateway services:
const { ServiceBroker } = require('moleculer')
const ApiGateWay = require('moleculer-web')

const broker = new ServiceBroker({
    transporter:'TCP'
})

//Back end Service
broker.createService({
    name: 'hello',
    actions: {
        sayHello: {
            handler(ctx) {
                return 'Hello,REST Service'
            }
        }
    }
})


//Gate Way Service
broker.createService({
    name: 'ApiGateWay',
    mixins: [ApiGateWay]
})
async function main() {
    await broker.start();
}
main();

Back End Services:

App1
const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker({
    transporter:"TCP"
})

// const broker = new ServiceBroker({
//     transporter:"nats://localhost:4222"
// })

broker.createService({
    name: 'math',
    actions: {
        add: {
            //param validation logic
            params: {
                a: "number",
                b: "number"
            },
            //biz logic 
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                //service to service communication via context object 
                return ctx.call('adder.add', { a: a, b: b })
            }
        },
        multiply: {
            //param validation logic
            // params: {
            //     a: "number",
            //     b: "number"
            // },
            //biz logic 
            handler(ctx) {
                const a = parseInt(ctx.params.a)
                const b = parseInt(ctx.params.b)
                //service to service communication via context object 
                return ctx.call('multiplier.multiply', { a: a, b: b })
            }
        },
    }
})

broker.createService({
    name: 'adder',
    actions: {
        add: {
            //param validation logic
            params: {
                a: "number",
                b: "number"
            },
            //biz logic 
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                return a + b
            }
        }
    }
})




async function main() {
    try {
        //start the broker 
        await broker.start()
        //use repl prompt
        broker.repl()

    } catch (err) {
        console.log(err)
    }
}
main()

App2:
const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker({
    transporter: "TCP"
})

// const broker = new ServiceBroker({
//     transporter:"nats://localhost:4222"
// })

broker.createService({
    name: 'multiplier',
    actions: {
        multiply: {
            //param validation logic
            params: {
                a: "number",
                b: "number"
            },
            //biz logic 
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                return `${a * b} from ${ctx.nodeID}`
            }
        }
    }
})



async function main() {
    try {
        //start the broker 
        await broker.start()
        //use repl prompt
        broker.repl()

    } catch (err) {
        console.log(err)
    }
}
main()

Test:

http://localhost:3000/math/multiply?a=10&b=10

Response
"100 from laptop-r2tggfdl-58588"
.....................................................................................
const { ServiceBroker } = require('moleculer')
const ApiGateWay = require('moleculer-web')

const broker = new ServiceBroker({
    transporter: 'TCP',
    serializer: "JSON" // not necessary to set, because it is the default
});

// /GateWayService
broker.createService({
    name: 'ApiGateWay',
    mixins: [ApiGateWay],
    //override ApiGateWayService properties
    settings: {
        routes: [{
            path: '/api'
        }, {
            path: '/admin'
        }]
    }
})

broker.createService({
    name: 'greeter',
    actions: {
        sayHello() {
            return 'Hello!';
        }
    }
})

broker.createService({
    name: 'admin',
    actions: {
        getAdmin() {
            return 'Admin!';
        }
    }
})

async function main() {
    await broker.start();
}
main();
....................................................................................
    		How to restrict service method/actions access outside
				whiteList - configuration
...................................................................................

const { ServiceBroker } = require('moleculer')
const ApiGateWay = require('moleculer-web')

const broker = new ServiceBroker({
    transporter: 'TCP',
    serializer: "JSON" // not necessary to set, because it is the default
});

// /GateWayService
broker.createService({
    name: 'ApiGateWay',
    mixins: [ApiGateWay],
    //override ApiGateWayService properties
    settings: {
        routes: [{
            path: '/api',
            whitelist: [
                "greeter.sayHello",
                "greeter.sayHai"
            ]
        }, {
            path: '/admin'

        }]
    }
})

broker.createService({
    name: 'greeter',
    actions: {
        sayHello() {
            return 'Hello!';
        },
        sayHai() {
            return 'Hai!';
        },
        sayGreet() {
            return 'Greet!';
        }
    }

})

broker.createService({
    name: 'admin',
    actions: {
        getAdmin() {
            return 'Admin!';
        }
    }
})

async function main() {
    await broker.start();
}
main();
....................................................................................

			URL Mapping in moleculer
..................................................................................

http://localhost:3000/api/serviceName/actionName

  This is not good way to map urls , which more difficult to remember, it is not user friendly
it is not even secure,the reason, we expose the back end service to end users.

Aliases:
........
  You can use aliases(dummyname/fakename)-Virtual path, instead of action name.

 settings: {
        routes: [
            {
                path: "/api",
                aliases: { 
                    "hello" : "greeter.hello",
                    "users" :  "users.list"
                }             
            }
        ]

http://localhost:3000/api/hello
http://localhost:3000/api/users

const { ServiceBroker } = require('moleculer')
const ApiGateWay = require('moleculer-web')

const broker = new ServiceBroker({
    transporter: 'TCP',
    serializer: "JSON" // not necessary to set, because it is the default
});

// /GateWayService
broker.createService({
    name: 'ApiGateWay',
    mixins: [ApiGateWay],
    //override ApiGateWayService properties
    settings: {
        routes: [{
            path: '/api',
            aliases: {
                "hello": "greeter.sayHello",
                "hai": "greeter.sayHai",
                "greet": "greeter.sayGreet"
            }

        }, {
            path: '/admin'

        }]
    }
})

broker.createService({
    name: 'greeter',
    actions: {
        sayHello() {
            return 'Hello!';
        },
        sayHai() {
            return 'Hai!';
        },
        sayGreet() {
            return 'Greet!';
        }
    }

})



async function main() {
    await broker.start();
}
main();
.....................................................................................	
const { ServiceBroker } = require("moleculer");
const ApiGateWayService = require("moleculer-web");
const PRODUCTS = require('../mock-data/products')

const broker = new ServiceBroker();

//CURD service : 

broker.createService({
    name: 'products',
    actions: {
        //GET ALL products
        list: {
            handler(ctx) {
                return PRODUCTS;
            }
        },
        //GET product by id
        get: {
            handler(ctx) {
                console.log(ctx.params)
                return PRODUCTS.filter(product => product.id == ctx.params.id)
            }
        },
        //save
        create(ctx) {
            console.log(ctx.params)
            return 'Product Created'
        },
        //update
        update(ctx) {
            return 'Product updated'
        },
        //delete
        remove(ctx) {
            return 'Product removed'
        }
    }
})


broker.createService({
    name: 'APIGateWay',
    mixins: [ApiGateWayService],
    settings: {
        routes: [{
            path: '/api',
            aliases: {
                "GET products": "products.list",  //GET list is default method
                "GET products/:id": "products.get", //users/1 users/2 users/3
                "POST products": "products.create",
                "PUT products/:id": "products.update",
                "DELETE products/:id": "products.remove"
            }
        }]
    }
})


async function init() {
    try {
        await broker.start();
    }
    catch (e) {
        log(e);
    }
}
init();
SHORT Cut 


Without short cut
  aliases: {
                "GET users": "user.list",  //GET list is default method
                "GET users/:id": "user.get", //users/1 users/2 users/3
                "POST users": "user.create",
                "PUT users/:id": "user.update",
                "DELETE users/:id": "user.remove"
            }
With Short cut

it will map actions automatically but there is rule , method names should be like below
 aliases: { 
   "REST users" : "users"
 }

method names:
 list
 get
 create
 update
 remove


const { ServiceBroker } = require("moleculer");
const ApiGateWayService = require("moleculer-web");

const PRODUCTS = [{
    id: 1,
    name: 'a'
}]

const broker = new ServiceBroker();

//CURD service : 

broker.createService({
    name: 'products',
    actions: {
        //GET ALL products
        list: {
            handler(ctx) {
                return PRODUCTS;
            }
        },
        //GET product by id
        get: {
            handler(ctx) {
                console.log(ctx.params)
                return PRODUCTS.filter(product => product.id == ctx.params.id)
            }
        },
        //save
        create(ctx) {
            console.log(ctx.params)
            return 'Product Created'
        },
        //update
        update(ctx) {
            return 'Product updated'
        },
        //delete
        remove(ctx) {
            return 'Product removed'
        }
    }
})


broker.createService({
    name: 'APIGateWay',
    mixins: [ApiGateWayService],
    settings: {
        routes: [{
            path: '/api',
            aliases: {
                "REST products": "products"
            }
        }]
    }
})


async function init() {
    try {
        await broker.start();
    }
    catch (e) {
        log(e);
    }
}
init();


...................................................................................
		  	Convert any back end service into rest api
....................................................................................
			Auto aliases: without mapping rest api 
.....................................................................................
Actions can be converted into rest api.

      list:{
	  // /api/users/
	   rest : "GET /"       
	   handler(ctx){

	   }
        }

      get:{
	  // /api/users/
	   rest : "GET /:id"       
	   handler(ctx){

	   }
        }

     save:{
	  // /api/users/
	   rest : "POST /"       
	   handler(ctx){

	   }
        }			



const { ServiceBroker } = require("moleculer");
const ApiGateWayService = require("moleculer-web");
const PRODUCTS = require('../mock-data/products')

const broker = new ServiceBroker();

broker.createService({
    name: 'products',
    actions: {
        //GET ALL products
        list: {
            rest: "GET /",
            handler(ctx) {
                return PRODUCTS;
            }
        },
        //GET product by id
        get: {
            rest: "GET /:id",
            handler(ctx) {
                console.log(ctx.params)
                return PRODUCTS.filter(product => product.id == ctx.params.id)
            }
        },
        //save
        create: {
            rest: "POST /",
            handler(ctx) {
                console.log(ctx.params)
                return 'Product Created'
            }
        },
        //update
        update: {
            rest: "PUT /:id",
            handler(ctx) {
                console.log(ctx.params)
                return 'Product update'
            }
        },
        //delete
        remove: {
            rest: "DELETE /:id",
            handler(ctx) {
                console.log(ctx.params)
                return 'Product update'
            }
        }
    }
})


broker.createService({
    name: 'APIGateWay',
    mixins: [ApiGateWayService],
    settings: {
        routes: [{
            path: '/api',
            aliases: {
            },
            autoAliases: true
        }]
    }
})

async function main() {
    try {
        await broker.start();
    }
    catch (e) {
        log(e);
    }
}
main()
Advanced Configurations

port,host,http2,https
.....................
settings: {
		// Exposed port
		port: 4000,

		// Exposed IP
		ip: "0.0.0.0",

		// HTTPS server with certificate
		https: {
			key: fs.readFileSync(path.join(__dirname, "../ssl/key.pem")),
			cert: fs.readFileSync(path.join(__dirname, "../ssl/cert.pem"))
		},

		//http2: true,

		// Global CORS settings
		cors: {
			origin: "*",
			methods: ["GET", "OPTIONS", "POST", "PUT", "DELETE"],
			allowedHeaders: "*",
			//exposedHeaders: "*",
			credentials: true,
			maxAge: null
		},

		// Rate limiter
		rateLimit: {
			window: 10 * 1000,
			limit: 10,
			headers: true
		},

		etag: true
}
.....................................................................................
			Data integration with Rest api
.....................................................................................

As we disucssed already, you can integrate database - prisma,moleculer-db module..

.....................................................................................

....................................................................................
			Microservice Design patterns 

1.Service Discovery and Registry
2.Load Balancer
3.Relability Pattern
4.Management Patterns - tracing,metrics
5.Caching...
6.Logging
Modular apps using molculer-cli -realtime project structure...



		           Service Registry and Discovery
.....................................................................................

1.Service Registry

 It is mini /small database , key-value pair database, in memory database.
 Which has all service,actions,event listeners, nodes information.

Points:
1.Every Broker has in built Service Registry
     Moleculer has built in in-memory registry, we can use that registry directly.

2.All services local or remote are registered with service registry as soon you create   service

3.Molecular has built in registry called LocalDiscoveryRegistry, which is not using third party registry servers
  like apache zoo keeper,consule,etcd,eurka....

4.if you want to make other servers as service registry -

   registry: {
        discoverer: "redis://redis-server:6379"
    }  
const broker = new ServiceBroker({
registry: {
        discoverer: "redis://redis-server:6379"
    } 
});

What is discovery?
   
   Discovery  means the lookup, search, we are going to search "services" from the registry infra structure.

         "All Services when is created is registered in Service Registry"

Moleculer looks up services from the registry by name.
You can change registery server from LocalDiscover to Redis,etcd3,

1.Start Redis Server.

docker run  -p 6379:6379 redis

2.install redis driver
npm install ioredis --save

const broker = new ServiceBroker({
    transporter: "nats://localhost:4222",
    registry: {
        //discoverer:'Redis'
        discoverer: "redis://localhost:6379"
    }
});

[2021-07-31T08:44:43.219Z] INFO  laptop-r2tggfdl-24816/REGISTRY: Discoverer: RedisDiscoverer

.....................................................................................
				..............................................................................................
			High Availability and scalibity
..............................................................................................
			   	
 				  Load Balancing

In Server-side load balancing, the instances of the service are deployed on multiple servers and then a load balancer is put in front of them. It is generally a hardware load balancer. All the incoming requests traffic firstly comes to this load balancer acting as a middle component. It then decides to which server a particular request must be directed to based on some algorithm.

Disadvantages of Server-side load balancing:

Server side load balancer acts as a single point of failure as if it fails, all the instances of the microservice becomes inaccessible as only load balancer has the list of servers.

Since each microservice will have a separate load balancer, the overall complexity of the system increases and it becomes hard to manage.

The network latency increases as the number of hops for the request increases from one to two with the load balancer, one to the load balancer and then another from load balancer to the microservice.


2. Client-side Load Balancing

The instances of the service are deployed on multiple servers. Load balancer's logic is part of the client itself, it holds the list of servers and decides to which server a particular request must be directed to based on some algorithm. These client side load balancers are also known as software load balancers.

Disadvantages of Client-side load balancing
The load balancer's logic is mixed up with the microservice code.


............................

Server side Load balancer is very usefull to manage trafic from outside applications.
Mobile clients and webclients trafic easily can be managed.

Client side load balancers are very usefull to mangae trafic inside microservice application.


Why we need load balancer?

1. To scale services instances
 A single service may not sufficient to handle multiple concurrent request.

How to select which service instance to be assigned to caller(client), 

   With help of Load Balancer.

Load Balancer balances incomming load and route according to "router algorthims" provided by load balancers.


Built-in strategies

 ->RoundRobin strategy
	This strategy selects a node based on round-robin algorithm.
   Refer:https://en.wikipedia.org/wiki/Round-robin_DNS
 ->Random strategy
	This strategy selects a node randomly.
 ->CPU usage-based strategy
	This strategy selects a node which has the lowest CPU usage. Due to the node list can 	be very long, it gets samples and selects the node with the lowest CPU usage from only 	samples instead of the whole node list.

 ->Latency-based strategy
	This strategy selects a node which has the lowest latency, measured by periodic ping commands. Notice that the strategy only ping one of nodes from a single host.

In Moleculer load balancers are built in, part of Registry , which is part of broker.

Moleculer loader balancer by default uses RoundRobin algorthim, if you want to change different one, you can override

 registry: {
        strategy: "Latency",
        strategyOptions: {
            sampleCount: 15,
            lowLatency: 20,
            collectCount: 10,
            pingInterval: 15
        }
    }

In Moleculer load balancers are built in, part of Registry , which is part of broker.

Moleculer loader balancer by default uses RoundRobin algorthim, if you want to change different one, you can override

 registry: {
        strategy: "Latency",
        strategyOptions: {
            sampleCount: 15,
            lowLatency: 20,
            collectCount: 10,
            pingInterval: 15
        }
    }

How to implement load balancing?

1.You need to clone the services n- number of times.
  lets say i have service called "adder" service , i need to run adder service 2 instances

2.Each service is going to run in different nodes. Each node must be identified quickly.
  Node name should not be hardcoded.
  In Genernal Node Id would be  - computername_processId

How to test ?

Open 3 cmd 
PS G:\IBM\2024\May\Nodejs\microservices\loadbalancing\add-service> node services/add.service.js

PS G:\IBM\2024\May\Nodejs\microservices\loadbalancing\add-service> node services/add.service.js
PS G:\IBM\2024\May\Nodejs\microservices\loadbalancing\add-service> node services/add.service.js



How to implement load balancing?

1.You need to clone the services n- number of times.
  lets say i have service called "adder" service , i need to run adder service 2 instances

2.Each service is going to run in different nodes. Each node must be identified quickly.
  Node name should not be hardcoded.
  In Genernal Node Id would be  - computername_processId


..................................................................................
		     Fault tolerance  Design pattern
..................................................................................

In Microservices, services are talking each other, while talking there are possiblity.

A. Callee Service may slow than expected duration by caller. - Slow calls

B. Callee may throw error , then caller gets exception which will be progataged across the app
   which may stop the entire app.

How to deal / solve the problem of above one ?

   Via Realibility pattern, we can solve the Problem.

Moleculer Provides Fault tolerance , through which we can solve
 

-Timeout

    Service-X  is calling Service-Y

1.You may get Result(succees/errors) "on time".

2.YOu may not get any thing beyond time.

3.Timeout defines deadlines for services


eg:
   Service-X expects result in 500 ms from Service-Y, What if Service-Y not able to give result within that time line , Service-Y will throw TimeoutException.

Now you need to decide how to Handle TimeoutException?

 -throw exception and handle it
 -You can have alternate fallback api to return result to the caller.


Any falut tolerence alogorthim in moleculer can be configured in two places

1.At broker level
const broker = new ServiceBroker({
    requestTimeout: 5 * 1000 // in milliseconds
});

2.At service level

broker.call("posts.find", {}, { timeout: 3000 });


services/timeoutmain.service.js


const { ServiceBroker } = require('moleculer');

const broker = new ServiceBroker({
    transporter: "TCP",
    requestTimeout: 5 * 1000 // in milliseconds

});
broker.createService({
    name: 'main',
    actions: {

        begin: {
            // Call the 'getCachedResult' method when error occurred
            fallback: "getCachedResult",
            async handler(ctx) {
                const { a, b, timeout } = ctx.params
                let res = await ctx.call('remotetimeout.calculate', { a, b }, {
                    timeout: timeout
                })
                console.log(`Result Got From Remote Services ${res}`)
            }
        }

    },
    methods: {
        getCachedResult() {
            return `From the Cache 0`
        }
    }
})
async function init() {
    await broker.start()
    broker.repl()
}
init();

services/remotetimeout.service.js
const { ServiceBroker } = require('moleculer');

const broker = new ServiceBroker({
    transporter: "TCP",
    requestTimeout: 5 * 1000 // in milliseconds
});

broker.createService({
    name: 'remotetimeout',
    actions: {
        async calculate(ctx) {
            const { a, b } = ctx.params
            return new Promise((resolve, reject) => {
                setTimeout(resolve, 3000, `${a + b} - ${broker.nodeID} `)
            })
        }
    }
})

async function init() {
    await broker.start()
    broker.repl()
}
init();

call main.begin --a 10 --b 20 --timeout 5000
>> Call 'main.begin' with params: { a: 10, b: 20, timeout: 5000 } with meta: { '$repl': true } with options: {}
Result Got From Remote Services 30 - laptop-r2tggfdl-13828

call main.begin --a 10 --b 20 --timeout 2000
>> Call 'main.begin' with params: { a: 10, b: 20, timeout: 2000 } with meta: { '$repl': true } with options: {}
[2022-05-27T09:43:13.543Z] WARN  laptop-r2tggfdl-13612/BROKER: Request 'remotetimeout.calculate' is timed out. { requestID: '6e3a1abe-432d-41eb-9311-ee9026e207e5', nodeID: 'laptop-r2tggfdl-13828', timeout: 2000 }
[2022-05-27T09:43:13.544Z] WARN  laptop-r2tggfdl-13612/MAIN: The 'main.begin' request is failed. Return fallback response. { requestID: '6e3a1abe-432d-41eb-9311-ee9026e207e5', err: "Request is timed out when call 'remotetimeout.calculate' action on 'laptop-r2tggfdl-13828' node." }
>> Execution time:2s
>> Response:
'From the Cache 0'
.....................................................................................	
.....................................................................................
			Moleculer cli and Moleculer Runner
....................................................................................

Moleculer Runner
 Moleculer Runner is a helper script that helps you run Moleculer projects. With it, you don’t need to create a ServiceBroker instance with options. Instead, you can create a moleculer.config.js file in the root of repo with broker options. Then simply call the moleculer-runner in NPM script, and it will automatically load the configuration file, create the broker and load the services. Alternatively, you can declare your configuration as environment variables.

Moleculer cli
 Provides features
1.create projects
2.mananage project life cycles
3.which embeded moleculer runner.

npm i -g moleculer-cli

























  

































